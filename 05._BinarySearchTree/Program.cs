namespace _05._BinarySearchTree
{
    // 탐색? 원하는 값 찾기
    // 일반적으로 하는 탐색은 순차탐색(전부 찾아서 원하는 값 하나 찾아내기)
    // 조금 더 빠르게 하려면? -> 이진탐색 이용(반절씩 나눠가며 찾기)
    // 이진탐색은 자료가 1억개여도 30번, 2억개여도 31번이면 찾을 수 있음
    // 다만 이진 탐색을 쓰려면 자료를 정렬해야하고, 그 자료구조로써 이진탐색트리가 좋음

    class Program
    {
        // 이진탐색트리 (BinarySearchTree)

        // 이진속성과 탐색속성을 적용한 트리
        // 이진탐색을 통한 탐색영역을 절반으로 줄여가며 탐색 가능
        // 이진 : 부모노드는 최대 2개의 자식노드를 가질 수 있음
        // 탐색 : 자신의 노드보다 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치

        // ex) 1 2 3 4 5 6 7 8 9 에서 8 찾기?

        // 1. 앞에서부터 하나씩 비교해가며 찾기(n개 중 n번 비교하기 / 순차탐색O(n))
        // 1이 8인가?, 2이 8인가 ...

        // 2. 자료가 정렬 되어 있으면? -> 중간 값을 확인해보기(이진 탐색 O(logn))
        // 5와 비교해서 8이 더 크니 오른쪽에 있을 거다...
        // 나머지 중에서도 절반씩 나눠가며 찾으면 훨씬 더 빠른 방법

        // 이진 탐색을 사용하기 위한 조건?
        // -> 정렬된 데이터에만 사용할 수 있음(순차 탐색은 정렬이 되어있지 않아도 됨)

        // 자료를 정렬만 할 수 있다면? -> 이진 탐색을 사용할 수 있고
        // => 탐색 상황에서 굉장히 큰 장점이 생김(1024개를 탐색하기 위해 10번이면 해결 가능 2^10)

        // 이진탐색트리의 원리
        // -> 데이터를 담을 때 노드로 만들고 값을 비교하여 작으면 왼쪽으로, 크면 오른쪽으로 추가함
        // 부모를 기준으로 작은 값은 왼쪽 자식으로 큰 값은 오른쪽 자식에 둔다(자식 최대 2개까지)

        // 이진탐색트리 -> 갈래가 나뉜 자료형태 -> 트리라는 자료형태!!

        // <이진탐색트리 구현>
        // 이진탐색트리는 모든 노드들이 최대 2개의 자식노드를 가질 수 있으며
        // 자신의 노드보다 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치시킴
        //
        //             23
        //      ┌──────┴──────┐
        //      11            38
        //   ┌──┴──┐       ┌──┴──┐
        //   3     19      31    65
        //   └─┐ ┌─┴─┐   ┌─┘     └─┐
        //     6 17  22  24        87

        // <이진탐색트리 탐색>
        // 아래의 이진탐색트리에서 17 탐색
        // 루트 노드부터 시작하여 탐색하는 값과 비교하여,
        // 작은 경우 왼쪽자식노드로, 큰 경우 오른쪽자식노드를 탐색
        //
        //             23(↙)
        //      ┌──────┴──────┐
        //      11(↘)        38
        //   ┌──┴──┐       ┌──┴──┐
        //   3     19(↙)  31    65
        //   └┐  ┌─┴─┐   ┌─┘
        //    6 (17) 22  24


        // <이진탐색트리 삽입>
        // 아래의 이진탐색트리에서 35 삽입
        // 루트 노드부터 시작하여 삽입하는 값과 비교하여,
        // 작은 경우 왼쪽자식노드로, 큰 경우 오른쪽자식노드로 하강
        // 만약 빈공간이라면 빈공간에 삽입
        //
        //             23(↘)                          23
        //      ┌──────┴──────┐                ┌──────┴──────┐
        //      11           38(↙)            11            38
        //   ┌──┴──┐       ┌──┴──┐      =>  ┌──┴──┐       ┌──┴──┐ 
        //   3     19      31(↘)65         3     19      31    65
        //   └─┐ ┌─┴─┐   ┌─┘                └─┐ ┌─┴─┐   ┌─┴─┐
        //     6 17  22  24                   6 17  22  24 (35)


        // <이진탐색트리 삭제>
        // 1. 자식이 0개인 노드의 삭제 : 단순 삭제 진행
        // 아래의 이진탐색트리에서 22 삭제
        //
        //             23                             23
        //      ┌──────┴──────┐                ┌──────┴──────┐
        //      11            38               11            38
        //   ┌──┴──┐       ┌──┴──┐    =>    ┌──┴──┐       ┌──┴──┐
        //   3     19      31    65         3     19      31    65
        //   └─┐ ┌─┴─┐   ┌─┘                └─┐ ┌─┘     ┌─┴─┐
        //     6 17 (22) 24                   6 17      24  35
        //
        // 2. 자식이 1개인 노드의 삭제 : 삭제하는 노드의 부모와 자식을 연결 후 삭제
        // 아래의 이진탐색트리에서 38 삭제
        //
        //            23                              23
        //     ┌──────┴──────┐                 ┌──────┴──────┐
        //     11           (38)               11            31
        //  ┌──┴──┐       ┌──┘        =>    ┌──┴──┐       ┌──┴──┐ 
        //  3     19      31                3     19      24    35
        //  └─┐ ┌─┴─┐   ┌─┴─┐               └─┐ ┌─┴─┐
        //    6 17  22  24  35                6 17  22
        //
        // 3. 자식이 2개인 노드의 삭제 : 삭제하는 노드를 기준으로 오른쪽자식 중 가장 작은 값 노드와 교체 후 삭제
        // 아래의 이진탐색트리에서 23 삭제
        //
        //           (23)                             24                              24
        //     ┌──────┴──────┐                 ┌──────┴──────┐                 ┌──────┴──────┐
        //     11            38                11            38                11            38
        //  ┌──┴──┐       ┌──┴──┐     =>    ┌──┴──┐       ┌──┴──┐     =>    ┌──┴──┐       ┌──┴──┐ 
        //  3     19      24    49          3     19     (23)   49          3     19      35   49
        //  └─┐ ┌─┴─┐     └─┐               └─┐ ┌─┴─┐     └─┐               └─┐ ┌─┴─┐
        //    6 17  22      35                6 17  22      35                6 17  22

        // 23을 삭제하려고 함
        // 1. 23(삭제할 값)과 24(오른쪽 자식 중 가장 작은 값)교체
        // 2. 23노드 삭제


        // <이진탐색트리 정렬>
        // 이진탐색트리는 중위순회시 오름차순으로 정렬됨
        //
        //             7
        //      ┌──────┴──────┐
        //      4             11
        //   ┌──┴──┐       ┌──┴──┐
        //   2     5       9     12
        // ┌─┴─┐   └─┐   ┌─┴─┐
        // 1   3     6   8   10
        //
        // 중위순회 : ((1, 2, 3), 4, (5, 6)), 7, ((8, 9, 10), 11, 12)
        //            => 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12

        // <이진탐색트리 시간복잡도>
        // - 평균 -
        // 접근       탐색       삽입       삭제
        // O(logn)    O(logn)   O(logn)    O(logn)


        // 이진탐색트리의 한계점?
        // -> 반분할 자료구조는 좋은 자료구조는 맞음
        // 만약 1 -> 2 -> 3 -> 4 -> 5 추가이면? 한줄로 긴 트리가 완성
        // => 이진탐색이 아니게 되어버림(효율이 떨어짐)
        // - 최악 -
        // 접근       탐색       삽입       삭제
        // O(n)       O(n)       O(n)      O(n)


        // <이진탐색트리 주의점>
        // 이진탐색트리는 최악의 상황에 노드들이 한쪽 자식으로만 추가되는 불균형 현상이 발생 가능
        // 이 경우 탐색영역이 절반으로 줄여지지 않기 때문에 시간복잡도 증가
        //
        //           5
        //         ┌─┘
        //         4
        //       ┌─┘
        //       3
        //     ┌─┘
        //     2
        //   ┌─┘
        //   1
        //

        // 그냥 사용하기에 곤란하니 밸런싱을 맞춰줘야 함
        // 이러한 현상을 막기 위해 자가균형기능을 추가한 트리의 사용이 일반적
        // 자가균형트리는 회전을 이용하여 불균형이 있는 상황을 해결
        //  
        //       8                        5
        //    ┌──┴──┐   -- 우회전 ->   ┌──┴──┐
        //    5     9                 3      8
        //  ┌─┴─┐       <- 좌회전 --       ┌─┴─┐      
        //  3   6                         6    9 
        //
        // 대표적인 방식으로 Red-Black Tree(C#), AVL Tree 등을 통해 불균형상황을 파악

        // 오른쪽이 길어지면? 좌회전
        // 왼쪽이 길어지면? 우회전

        //       3           2
        //     ┌─┘        ┌──┴──┐
        //     2     =>   1     3 : 우회전
        //   ┌─┘
        //   1
        //

        // 이진탐색트리가 한쪽으로만 치우쳐서 늘어나는 경우를 방지하기 위해 자가균형기능이 포함되어 있는 트리를 이용
        // 불균형이 파악되면 회전을 통해 균형을 맞춤

        // AVL tree
        // 각각 왼쪽 오른쪽의 깊이를 확인해서 2이상 차이나면 불균형이라 판단하고 회전 진행

        // Red-Black Tree(C#)
        // 빨간색과 검은색을 표시해서 빨간색이 2연속 있다면 불균형


        static void Main(string[] args)
        {
            // 이진탐색트리 기반의 SortedSet 자료구조
            // 중복이 없는 정렬을 보장한 저장소
            // Set? : 중복이 없는 저장소
            SortedSet<int> sortedSet = new SortedSet<int>();
            
            // 삽입
            // 1. Add -> 위에서 차례로 알아서 들어감
            sortedSet.Add(1);
            sortedSet.Add(5);
            sortedSet.Add(4);
            sortedSet.Add(3);
            sortedSet.Add(2);
            
            sortedSet.Add(3); // 중복 추가는 무시함. 이미 3이 있으므로 무시


            // 삭제
            // 1. Remove(value) -> value 지우기
            sortedSet.Remove(4); // O(logn)


            // 탐색
            // 1. Contains(value) -> value 찾기
            bool sucess = sortedSet.Contains(3);    // true
            bool fail = sortedSet.Contains(6);      // false

            
            // 반복하여 출력(중위순회)
            foreach(int value in sortedSet)
            {
                Console.WriteLine(value);       // output : 1 2 3 5
            }                                   // 순서를 보장해 줌
            Console.WriteLine();

            // ex) 포켓몬스터?
            // 파이리 공격력을 빨리 찾고 싶음 -> 이진탐색트리에 넣어봄
            // 파이리를 저장하고, 피카츄를 넣는데 -> 무슨 기준으로 비교하는지?
            // key와 value를 나눠보자 => key : 정렬 기준, value : 실제 데이터
            // key : 이름, value : 공격력, 방어력...
            // 이름(key) 기준으로 문자열을 비교 -> key 기준으로 '피카츄' 찾아줘 등등..

            SortedSet<Item> set = new SortedSet<Item>();
            set.Add(new Item("포션", 3));
            // set.Add(new Item("소드", 5)); 에러! 포션이 큰지 소드가 큰지 비교 불가(기준이 없음)
            // => sortedDictionary 자료구조 활용

            // 이진탐색트리 기반의 SortedDictionary 자료구조
            // 중복을 허용하지 않는 key를 기준으로 정렬을 보장한 value 저장소
            SortedDictionary<string, Item> sortedDictionary = new SortedDictionary<string, Item>();
            // <int, Item> : 기준은 int, 값은 Item객체

            // 삽입
            // 1. Add(key, value) : 기준은 key를 비교하여 정렬
            sortedDictionary.Add("포션", new Item("포션", 3));  // key : 포션, value : 아이템 객체
            sortedDictionary.Add("소드", new Item("소드", 5));  // key : 소드, value : 아이템 객체
            sortedDictionary.Add("방패", new Item("방패", 1));
            sortedDictionary.Add("신발", new Item("신발", 100));
            sortedDictionary.Add("롱소드", new Item("롱소드", 20));
            sortedDictionary.Add("망토", new Item("망토", 30));


            // sortedDictionary.Add("포션", new Item("포션", 20)); error : key 중복을 허용하지 않음
            sortedDictionary.TryAdd("포션", new Item("포션", 20)); // 가능. TryAdd 없으면 넣고 있으면 넣지마 
                                                                  // 예외처리까지 감안하여 key 추가

            // 삭제
            // 1. Remove(key) : key 값에 해당하는 자료 지우기
            sortedDictionary.Remove("롱소드");


            // 탐색
            // 1. ContainsKey(key) : key 값에 해당하는 자료 찾기
            bool success = sortedDictionary.ContainsKey("방패");

            // 찾아서 해당 value를 가져오기 위해 배열처럼 사용 가능
            // sortedDictionary[key]
            Item item1 = sortedDictionary["방패"];                  // 인덱서[key]를 가지고 탐색
            Item item2 = sortedDictionary["포션"];

            // TryGetValue? 있으면 주고 없으면 주지마
            sortedDictionary.TryGetValue("방패", out Item shield); // 예외처리까지 감안하여 key 가지고 value 탐색
            sortedDictionary.TryGetValue("포션", out Item potion);

            // 반복하여 출력
            foreach (string name in sortedDictionary.Keys)
            {   // key(string) 값 활용
                Console.WriteLine(name);
            }
            Console.WriteLine();
            foreach (Item item in sortedDictionary.Values)
            {   // value(Item class) 값 활용
                Console.WriteLine($"{item.name}, {item.cost}");       
            }                                 
            Console.WriteLine();
        }

        public class Item
        {
            public string name;
            public int cost;

            public Item(string name, int cost)
            {
                this.name = name;
                this.cost = cost;
            }
        }
    }
}
