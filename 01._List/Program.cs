namespace _01._List
{
    class Program
    {
        // 리스트(List)

        // 런타임 중 크기를 확장할 수 있는 배열기반의 자료구조
        // 배열요소의 갯수를 특정할 수 없는 경우 사용이 용이

        // 리스트는 C#에서 가장 많이 이용되는 자료형태임
        // 효율이 좋고 사용량이 높으며 굉장히 많은 기능을 지원함
        // MSDN list 검색으로 기능을 검색할 수 있음

        // 리스트의 구현 원리

        // 리스트가 늘어나는 상황? -> 원할 때 메모리를 추가적으로 붙일 수 있다? -> 아님(불가능)
        // 사실 현실적으로 크기가 큰 배열로 구현되어 있음 -> 해당 배열을 일부분만 사용함으로써 마치 크기가 변화하는 것 처럼 보임
        // 즉 리스트는 크기 관리 => 배열의 길이가 아닌 크기(Count)로 관리

        // <리스트 구현>
        // 리스트는 배열기반의 자료구조이며, 배열은 크기를 변경할 수 없는 자료구조
        // 리스트는 동작 중 크기를 확장하기 위해 포함한 데이터보다 더욱 큰 배열을 사용
        //
        // 크기 = 3, 용량 = 8       크기 = 4, 용량 = 8       크기 = 5, 용량 = 8
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│ │ │ │ │ │        │1│2│3│4│ │ │ │ │        │1│2│3│4│5│ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘

        // <리스트 삽입>
        // 중간에 데이터를 추가하기 위해 이후 데이터들을 뒤로 밀어내고 삽입 진행
        //      ↓                        ↓                        ↓
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│ │ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│A│3│4│ │ │ │  (Insert)
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘

        //          ↓                        ↓                    
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐       
        // │1│2│3│4│ │ │ │ │   =>   │1│2│3│4│A│ │ │ │ (Add) -> 일반적인 상황에서 Add가 더 빠름(O(1))     
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘       

        // <리스트 삭제>
        // 중간에 데이터를 삭제한 뒤 빈자리를 채우기 위해 이후 데이터들을 앞으로 당김
        //      ↓                        ↓
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│A│3│4│ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│3│4│ │ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘

        //          ↓                        ↓                    
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐       
        // │1│2│3│4│A│ │ │ │   =>   │1│2│3│4│ │ │ │ │ (RemoveAt(list.Count -1)) -> 가장 마지막 인덱스를 지우는 경우(O(1))
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘       

        // <리스트 시간복잡도>
        // 접근    탐색     삽입    삭제
        // O(1)    O(n)    O(n)    O(n)


        // 리스트의 문제점
        // -> 만약 용량을 벗어나면? -> 너무 크게 잡자니 메모리 부담, 적게 잡자니 인덱스 오류
        // => 용량의 관리가 필요함(꽉차면 더 큰걸로 '새로' 만들어서 이전하자)

        // <리스트 용량 / Capacity>
        // 용량을 가득 채운 상황에서 데이터를 추가하는 경우
        // 더 큰 용량의 배열을 새로 생성한 뒤 데이터를 복사하여 새로운 배열을 사용
        //
        // 1. 리스트가 가득찬 상황에서 새로운 데이터 추가 시도
        // 크기 = 8, 용량 = 8
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│ ← A 추가
        // └─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // 2. 새로운 더 큰 배열 생성
        // 크기 = 8, 용량 = 8          크기 = 0, 용량 = 16
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│ ← A       │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘ 
        //
        // 3. 새로운 배열에 기존의 데이터 복사
        // 크기 = 8, 용량 = 8          크기 = 8, 용량 = 16
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│ ← A       │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // 4. 기본 배열 대신 새로운 배열을 사용(기존 배열은 삭제)
        // 크기 = 8, 용량 = 16
        // ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │ ← A 추가
        // └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // 5. 빈공간에 데이터 추가
        // 크기 = 9, 용량 = 16
        // ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│A│ │ │ │ │ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

        // 다음과 같이 리스트는 용량 관리를 수행함(작은 용량에서 점점 더 커지게)
        // -> 용량이 꽉 차면 새로운 배열을 만들고 비우는 과정에서 가비지 발생

        // Tip? 
        // 십만개의 데이터를 집어넣고 관리해야 한다 -> 처음부터 용량 설정이 필요함
        // -> 부담이 매우 줄어듦 => 즉 어느정도 예측이 가는 크기라면 용량 설정하기
        // list1.Capacity = 100000;
        // List<int> list1 = new List<int>(100000); 도 지원해주는 문법

        static void Main(string[] args)
        {
            // 배열의 아쉬운 점? => 유동적인 공간에서 처리가 어려움
            // 정해져 있는 크기가 아닌 데이터 집합
            // ex) 1 ~ 50 랜덤수 50개 중에서 3의 개수, 사정거리 안에 있는 몬스터가 몇마린지...
            // 넉넉하게 사용하자니 메모리 공간의 낭비(1000마리 중 5마리?)
            // 적게쓰자니 모든 상황에 대처할 수 없음
            string[] array = new string[5];

            // List클래스로 생성하며 일반화로 <자료형>이 필요함
            // List<int> -> int 리스트, List<char> -> char 리스트
            List<string> list = new List<string>();

            // 리스트와 배열의 차이점?
            // -> 배열은 5개의 공간을 미리 만들어두고 해당 공간만 이용(고정)
            // -> 리스트는 추가와 삭제로 공간이 유동적으로 변함
            // 크기가 확정될 땐 배열, 아니라면 리스트

            // 추가
            // 1. 이어 붙이기(Add)
            list.Add("0번째 데이터");   // 0
            list.Add("1번째 데이터");   // 0 1
            list.Add("2번째 데이터");   // 0 1 2
            list.Add("3번째 데이터");   // 0 1 2 3
            list.Add("4번째 데이터");   // 0 1 2 3 4
            // 2. 중간에 삽입하기(Insert)
            list.Insert(1, "중간 데이터 1에 추가"); // 1번 위치에 들어가고, 나머지는 한칸씩 밀림
                                                  // 0 5 1 2 3 4
            list.Insert(3, "중간 데이터 3에 추가"); // 3번 위치에 들어가고, 나머지는 한칸씩 밀림
                                                  // 0 5 1 6 2 3 4
            // 추가 시 Insert보다 Add를 권장함.

            // 삭제
            // 1. 특정 데이터 삭제(Remove)
            list.Remove("2번째 데이터"); // 해당 데이터 삭제하고 압축(삭제 이후의 데이터를 앞칸으로 이동)
                                        // 0 5 1 6 3 4
            list.Remove("3번째 데이터"); // 리스트는 기본적으로 빈칸을 허용하지 않음

            // 2. 특정 위치 데이터 삭제(RemoveAt)
            list.RemoveAt(2);                          // 2번 인덱스의 데이터 삭제
            list.Remove("10번째 데이터");               // 없는 데이터를 지우려면? 오류는 아니며 무시됨
            bool success = list.Remove("2번째 데이터"); // Remove의 결과는 true, false -> 해당 결과로 올바르게 데이터를 지웠는지 확인 가능


            // 접근(인덱서)
            list[0] = "수정된 0번 데이터"; // 배열과 동일하게 인덱서 지원해줌
            string text = list[2];

            // 배열은 Length(길이), 리스트는 Count(개수)로 반복문 활용
            for(int i = 0; i < list.Count; i++)
            {
                Console.WriteLine(list[i]);
            }
            //list.Capacity; -> 리스트의 용량

            // 탐색(IndexOf)
            int index = list.IndexOf("4번째 데이터"); // 있으면 해당 번호를 없으면 -1
        }
    }
}