namespace _07._Hashtable
{
    // 해시테이블 : 리스트 만큼이나 굉장히 중요한 자료 구조

    class Program
    {
        // 해시테이블(HashTable)

        // 키 값을 해시함수로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식
        // 해시 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑

        // 해시 + 테이블
        // 해시를 가지고 진행한 것을 테이블에 보관한다
        // 해시? -> 뭉개다, 다지다 -> 원형을 꽉꽉 뭉쳐놓는다
        // 원래의 데이터를 뭉쳐 뭉친 값을 가지고 특정 위치로 엑세스하는 방식

        // 이진트리 -> 좋고 효율적인 방법 중 하나 -> 더 빠를 순 없는지?
        // 배열을 아주 크게 만들고 특정 데이터의 키 값을 가지고 해당 인덱스에 저장
        // Data23을 저장? 인덱스 [23]에 저장/ Data101을 저장? 인덱스 [101]에 저장
        // -> 키 값만 있다면(인덱스만 알고 있으면) 바로 접근 가능

        // 다만? 150칸짜리 배열에 Data181데이터 저장하고 싶다? -> 인덱스 [181]이 테이블에 없음
        // 배열을 더 크게 만들면? -> 언제까지, 얼마나 크게? -> 모든 키에 대응하는 배열을 만들기에는 불가능에 가까움
        // ex) 181?? -> 숫자를 뭉쳐보자(해시)! -> 31로 바꿔서 저장 / 601? -> 해시 -> 1에 저장

        // 유한한 테이블의 크기에서 모든 숫자를 키 값으로 쓰기에 불가능 -> 숫자를 뭉쳐서 그 위치에 저장하자
        // 해시하고 테이블에 담자! -> 해시테이블

        // 181  해  -> 31 
        //                
        // 601  싱  -> 1  

        // <해시테이블 구현>
        // 데이터를 담을 테이블을 이미 크게 확보해 놓은 후
        // 입력받은 키를 해싱하여 테이블 고유한 index를 계산하고 데이터를 담아 보관
        // 
        //           해싱
        //          ┌────┐
        //     27 ─→│    │─→  27
        //    385 ─→│해시│─→ 192
        //    581 ─→│함수│─→   2
        //   1031 ─→│    │─→  66
        //          └────┘
        //
        //   [0]   [1]   [2]       [27]       [66]       [191] [192] [193]
        // ┌─────┬─────┬─────┬─  ─┬────┬─  ─┬──────┬─  ─┬─────┬─────┬─────┐
        // │     │     │ 582 │....│ 27 │....│ 1031 │....│     │ 385 │     │
        // └─────┴─────┴─────┴─  ─┴────┴─  ─┴──────┴─  ─┴─────┴─────┴─────┘

        // 어떠한 숫자라도 테이블에 저장할 수 있도록 변환하는 작업이라고 생각
        // 연산 한번으로 바로 데이터에 탐색, 삭제, 삽입을 할 수 있음(O(1))

        // 빈 공간이 많더라도 속도를 위해 사용하는 방식
        // 무슨 원리로 해시 함수를 만들지? (어떻게 뭉치지?)

        // <해시 함수>
        // 키값을 해싱하여 고유한 index를 만드는 함수
        // 하나의 키값을 해싱하는 경우 반드시 항상 같은 결과여야 함
        // 효율 : 해시의 결과가 분산적일수록 효율이 좋음(충돌 때문에)

        // 1 2 3 4
        // 1      2      3      4 => 효율 더 좋음
        
        // 1. 나눗셈법 : 데이터 % 테이블크기

        // ex) 테이블 크기 : 1000
        // key : 201 -> 201
        // key : 1121 -> 121
        // key : 338746 -> 746

        // key : "pikachu"?? -> 116 + 107..
        // 어차피 문자도 메모리에 아스키코드로 들어가 있으니 충분히 가능
        // 자료에 무관하게 숫자로 바꿀 수 있으니 굉장히 쉬운 방법

        // 2. 자리수접기 : 데이터의 각 자리수의 합

        // key : 201 -> 3
        // key : 1121 -> 5
        // key : 338746 -> 31

        // 3. SHA-2 : 미국 국가안보국(NSA)이 설계한 암호화 해시 함수

        // 나눗셈법   예시 : 132031 → (132031 % 1000) = 31
        // 자리수접기 예시 : "hash" → h(104) + a(97) + s(115) + h(104) = 420

        // 정리
        // 1. 데이터를 담을 수 있는 큰 테이블(배열)을 만들고
        // 2. 데이터를 해시하여 테이블 내 들어갈 수 있도록 주소를 계산하고, 해당 주소에 데이터를 담는 것
        // 3. 데이터를 찾고싶다면 해시함수를 통해 키 값을 찾고 해당 해시테이블에 키 값을 이용하여
        // 접근하면 해당 데이터가 들어있을 거다

        // <해시테이블의 시간복잡도>
        // 접근       탐색       삽입       삭제
        //  X         O(1)      O(1)       O(1)

        // 접근의 용도가 아님(0번째, 1번째 데이터 가져오기)
        // 해시테이블은 키값을 무시하고 단순 접근하는 것이 아님.

        // <해시테이블 주의점 - 충돌>
        // 해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는 것
        // 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음
        //
        //           해싱
        //          ┌────┐
        //    274 ─→│해시│─→  81
        //    660 ─→│함수│─→  81
        //          └────┘
        //
        //   [0]   [1]   [2]         [81]         [191] [192] [193]
        // ┌─────┬─────┬─────┬─  ─┬─────────┬─  ─┬─────┬─────┬─────┐
        // │     │     │     │....│ 274 660 │....│     │     │     │
        // └─────┴─────┴─────┴─  ─┴─────────┴─  ─┴─────┴─────┴─────┘

        // 충돌을 요약하자면 같은 공간을 쓰고 있는 문제
        // 해시 테이블에서 어쩔 수 없는 문제
        // -> 많은 키 값을 정해진 고정 값으로 줄이다보니 충돌을 피할 수 없음

        // 비둘기집 원리??
        // 테이블 크기가 9개다 -> 키 값이 10개이상 파생되면? -> 무조건 충돌임
        // 테이블은 유한한데 키 값은 무한하니 충돌 원리가 무조건 생김
        // => 충돌 하더라도 사용할 수 있는 방법들이 필요함

        // <충돌해결방안 - 체이닝>
        // 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식
        // 장점 : 해시테이블에 자료가 많아지더라도 성능저하가 적음
        // 단점 : 해시테이블 외 추가적인 저장공간이 필요
        //
        //           해싱
        //          ┌────┐
        //    274 ─→│해시│─→  81
        //    660 ─→│함수│─→  81
        //          └────┘
        //
        //   [0]   [1]   [2]        [81]      [191] [192] [193]
        // ┌─────┬─────┬─────┬─  ─┬─────┬─  ─┬─────┬─────┬─────┐
        // │     │     │     │....│  │  │....│     │     │     │
        // └─────┴─────┴─────┴─  ─┴──│──┴─  ─┴─────┴─────┴─────┘
        //                           ↓
        //                        ┌─────┬─┐ ┌─────┬─┐
        //                        │ 274 │──→│ 660 │ │
        //                        └─────┴─┘ └─────┴─┘

        // 충돌한 지점에 이진탐색트리를 활용함 -> 그래도 logN

        // 어차피 해시테이블은 크게 만들어야 하는데? -> 전체 공간 중 하나만 충돌나면?
        // 나머지 공간이 너무 아까움 -> 개방 주소법(나머지 빈 공간을 쓰자!!)

        // <충돌해결방안 - 개방주소법> => C#의 방법
        // 해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식
        // 해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정
        // 장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음
        // 단점 : 해시테이블에 자료가 많아질수록 성능저하가 많음
        //
        // 개방주소법 해시테이블의 공간 사용률이 높을 경우(통계적으로 70% 이상) 급격한 성능저하가 발생
        // 이런 경우 재해싱을 통해 공간 사용률을 낮추어 다시 효율을 확보함
        // 재해싱 : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱하여 보관
        //
        //           해싱
        //          ┌────┐
        //    274 ─→│해시│─→  81
        //    660 ─→│함수│─→  81
        //          └────┘
        //                          
        //   [0]   [1]   [2]        [81]  [82]      [191] [192] [193]
        // ┌─────┬─────┬─────┬─  ─┬─────┬─────┬─  ─┬─────┬─────┬─────┐
        // │     │     │     │....│ 274 │     │....│     │     │     │
        // └─────┴─────┴─────┴─  ─┴─────┴─────┴─  ─┴─────┴─────┴─────┘
        //                          ↑660(충돌)
        //
        //   [0]   [1]   [2]        [81]  [82]      [191] [192] [193]
        // ┌─────┬─────┬─────┬─  ─┬─────┬─────┬─  ─┬─────┬─────┬─────┐
        // │     │     │     │....│ 274 │ 660 │....│     │     │     │
        // └─────┴─────┴─────┴─  ─┴─────┴─────┴─  ─┴─────┴─────┴─────┘
        //                                ↑(다음위치에 저장)



        static void Main(string[] args)
        {
            // 해시테이블 기반의 HashSet 자료구조
            // 중복이 없는 해시기반의 저장소
            HashSet<string> set = new HashSet<string>();
            // SortedSet<int> set1 = new SortedSet<int>(); -> 이진탐색트리기반

            // SortedSet과 유사함. SortedSet은 정렬을 보장해줌
            // HashSet은 정렬을 보장해주진 않으나 삽입, 삭제, 탐색이 매우 빠름(O(1))
           
            // 삽입
            // 1. Add
            set.Add("D");
            set.Add("B");
            set.Add("B"); // 중복은 무시
            set.Add("C");
            set.Add("A");
            set.Add("A");
            set.Add("A");
            set.Add("E");

            // 순서대로 출력시 포함된 순서대로 결과 확인
            foreach(string value in set)
            {
                Console.Write(value); // output : DBCAE
            }
            Console.WriteLine();

            // 삭제
            // 1. Remove : 결과 bool
            set.Remove("B");


            // 탐색
            // 1. Contains
            set.Contains("A");


            // 해시테이블 기반의 Dictionary 자료구조
            // 중복을 허용하지 않는 key를 기준으로 해시기반의 value 저장소
            // C# 탐색에 있어 Dictionary를 따라올 수 있는 자료구조가 없음.
            Dictionary<int, string> dictionary = new Dictionary<int, string>();

            //        SortedDictionary vs Dictionary
            //  기반 |  이진탐색트리     |   해시테이블
            //  중복 |     허용X        |    허용X
            //  정렬 |     보장         |    보장X
            //  속도 |   O(log N)       |    O(1)


            // 삽입
            // 1. Add(key, value) : key값 가지고 value 넣기
            // key 중복 불가
            // 2. TryAdd(key, value) : key값이 없다면 value 넣기
            dictionary.Add(2, "A");
            dictionary.Add(1, "B");
            dictionary.Add(4, "C");
            dictionary.Add(3, "D");
            dictionary.Add(5, "E");
            // dictionary.Add(4, "F");    // error : Dictionary는 key 중복을 허용하지 않음
            dictionary.TryAdd(4, "F");    // 안전하게 추가하기

            // 삭제
            // 1. Remove(key) : key값 가지고 삭제
            dictionary.Remove(5);

            // 탐색
            // 1. ContainsKey(key) : key값 가지고 value 찾기
            // 2. TryGetValue(key, out T value) : key값이 있다면 value 가져오기
            dictionary.ContainsKey(3);                        // 포함 확인
            dictionary.TryGetValue(3, out string dicValue);   // 탐색 시도

            // 순서대로 출력시 정렬된 결과 확인
            foreach (string value in dictionary.Values)
            {
                Console.Write(value);     // output : ABCD
            }
            Console.WriteLine();
        }
    }
}
