namespace _06._Heap
{
    // 메모리 영역의 힙과 다른 자료구조 힙

    // 이전의 이진탐색트리?

    // 1. 작은 값은 왼쪽, 큰 값은 오른쪽
    // 2. 최대 2개까지 자식을 가질 수 있다

    // 최대 2개의 자식은 동일하나 조금만 더 바꿔보자 ⇒ 힙

    // -> 부모가 두 자식보다 작다(최소 힙)
    // -> 부모가 두 자식보다 크다(최대 힙)

    class Program
    {
        // 힙(Heap)

        // 부모 노드가 자식노드보다 우선순위가 높은 속성을 만족하는 트리기반의 자료구조
        // 많은 자료 중 우선순위가 가장 높은 요소를 빠르게 가져오기 위해 사용
        // -> 굉장히 많은 자료 중 그 중에서 가장 크거나 작은 값을 찾을 때 맨 위에 값만 확인하면 됨

        // <힙 구현>
        // 힙은 노드들이 트리의 왼쪽부터 채운 완전이진트리를 구조를 가지며
        // 부모 노드가 두 자식노드보다 우선순위가 높은 값을 위치시킴
        // 힙 상태를 만족하는 경우 가장 최상단 노드가 모든 노드 중 우선순위가 가장 높음
        //
        //               2
        //       ┌───────┴───────┐
        //       8               52
        //   ┌───┴───┐       ┌───┴───┐
        //   13      37      67      92
        // ┌─┴─┐   ┌─┘
        // 17  43  52
        // 데이터를 삽입하고 삭제의 과정을 알아야 힙의 구현이 가능

        // 항상 힙을 유지하기 위해 부모 노드는 자식보다 작아야 함
        // 삽입을 하였을 때 새로운 데이터가 유지를 위해 상승 작업이 필요함

        // -> 가장 마지막에 삽입, 위의 부모와 비교하여 우선순위에 따라 교체하자
        // -> 이 작업을 교체되지 않을 때 까지 반복하자

        // <힙 노드 삽입>
        // 1. 힙의 최고 깊이, 최우측에 새 노드를 추가
        //
        //               2
        //       ┌───────┴───────┐
        //       8               52
        //   ┌───┴───┐       ┌───┴───┐
        //   13      37      67      92
        // ┌─┴─┐   ┌─┴─┐
        // 17  43  52 (7)
        //
        // 2. 삽입한 노드와 부모 노드를 비교하여 우선순위가 더 높은 경우 교체
        //
        //               2                               2                               2
        //       ┌───────┴───────┐               ┌───────┴───────┐               ┌───────┴───────┐
        //       8               52              8               52             (7)              52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
        //   13      37      67      92      13     (7)      67      92      13      8       67      92
        // ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐
        // 17  43  52 (7)                  17  43  52  37                  17  43  52  37
        //
        // 3. 더이상 교체되지 않을때까지 과정을 반복
        //
        //               2                               2
        //       ┌───────┴───────┐               ┌───────┴───────┐
        //      (7)              52              7               52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
        //   13      8       67      92      13      8       67      92
        // ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐
        // 17  43  52  37                  17  43  52  37

        // 하나를 꺼낼 땐 제일 위의 작은 값을 꺼내야 함
        // 맨 위의 노드를 지움 -> 끊겨버림 -> 대신 지워질 노드와 교체하고 삭제
        // 교체할 때도 힙의 상태를 유지해야 함 -> 하강 작업을 반복

        // <힙 노드 삭제>
        // 1. 최상단의 노드와 최우측 노드를 교체한 뒤 최우측 노드를 삭제
        //
        //              (2)                             (37)                           (37)
        //       ┌───────┴───────┐               ┌───────┴───────┐              ┌───────┴───────┐
        //       7               52              7               52             7               52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>  ┌───┴───┐       ┌───┴───┐
        //   13      8       67      92      13      8       67      92     13      8       67      92
        // ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐                  ┌─┴─┐   ┌─┘
        // 17  43  52 (37)                 17  43  52 (2)                 17  43  52
        //
        // 2. 교체된 노드와 두 자식 노드를 비교하여 우선순위가 더 높은 노드와 교체
        //
        //              (37)                             7                               7
        //       ┌───────┴───────┐               ┌───────┴───────┐               ┌───────┴───────┐
        //       7               52             (37)             52              8               52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
        //   13      8       67      92      13      8       67      92      13     (37)     67      92
        // ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘
        // 17  43  52                      17  43  52                      17  43  52
        //
        // 3. 더이상 교체되지 않을때까지 과정을 반복
        //
        //               7                               7
        //       ┌───────┴───────┐               ┌───────┴───────┐
        //       8               52              8               52
        //   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
        //   13     (37)     67      92      13      37      67      92
        // ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘
        // 17  43  52                      17  43  52

        // 질문 모음
        // 1. 메모리 힙과 자료구조 힙은 전혀 연관없음
        // 2. 단순히 부모가 가장 작으면 됨. 자식끼리 비교하여 변경할 필요는 없음
        // 3. 큐와 우선순위큐는 태생이 다름 -> 큐 : 순환배열, 우선순위큐 : 힙
        // 4. 최고 깊이 최우측 데이터가 가장 마지막 데이터
        // 5. 우선순위를 알 수 있는 방법?? -> 없다
        // 6. 하강작업은 두 자식 중 작은 값이랑 변경함 -> 힙은 왼쪽 오른쪽 없음 그냥 자식임
        // 7. 맨 마지막 노드? -> 가장 아래에서 제일 오른쪽
        // 8. 주제가 우선순위큐인 이유? -> 그냥
        // 9. 데이터의 순서는 위에서 아래, 왼쪽에서 오른쪽으로 생각
        // 10. C++이나 C#이나 힙 구현은 배열
        // 11. 힙은 최악의 경우에도 O(log n) -> 트리가 편향되지 않아서 항상 일정함
        // 12. 구현에서 배열을 리스트 때 처럼 만들어서 사용할 예정

        // 힙은 부모보다 두 자식이 크거나 작게끔 구현함
        // 힙은 구조상 삽입, 삭제의 과정에서도 전부 연산이 반절이 됨
        // 왜?? -> 상승 혹은 하강 과정에서 힙의 구조인 부모는 자식보다 작다라는 구조로 인해 교체가 일어날 때 나머지 자식과 비교할 이유가 없음
        // 어차피 부모가 가장 작은데 상승, 혹은 하강의 과정에서 부모와 비교하면 나머지 자식은 비교조차 할 이유가 없음

        // 상승할 때 만약 부모보다 작다면? 부모가 자식보다 작으니 당연히 부모의 자식들보다 훨씬 더 작음

        // 정리
        // 1. 다음 -> 최상단
        // 2. 추가 -> 마지막 추가 후 상승 반복
        // 3. 삭제 -> 최상단 출력 후 마지막과 교체 후 교체한 노드를 하강 반복

        // 힙의 소스 구현
        // 이진트리?? -> 트리 구조랑 유사하니까?
        // -> 보통 힙은 데이터를 차례대로 꽉 채워서 사용함 -> 구조상 훨씬 효율적이기 때문에
        // 굳이 노드를 사용하지 않아도 됨 -> 배열로도 충분히 가능

        // <힙 구현>
        // 힙의 완전이진트리 특징의 경우 배열을 통해서 구현하기 좋음
        // 노드의 위치를 배열에 순서대로 저장
        // 노드가 위치한 인덱스에 연산을 진행하여 노드 이동이 가능
        // 
        // 부모로 이동         : (index - 1) / 2
        // 왼쪽자식으로 이동   : 2 * index + 1
        // 오른쪽자식으로 이동 : 2 * index + 2
        //
        //        0
        //    ┌───┴───┐
        //    1       2       ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        //  ┌─┴─┐   ┌─┴─┐ =>  │0│1│2│3│4│5│6│7│8│9│
        //  3   4   5   6     └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        // ┌┴┐ ┌┘
        // 7 8 9

        // 위의 식 그대로 활용하면 부모와 자식을 찾을 수 있음
        // ex) 9의 부모? 9의 인덱스는 9, 부모의 인덱스는 (9 - 1) / 2 => 4
        // ex) 3의 부모? 3의 인덱스는 3, 부모의 인덱스는 (3 - 1) / 2 => 1
        // ex) 0의 왼쪽 자식? 0의 인덱스는 0, 왼쪽 자식의 인덱스는 (0 * 2) + 1 => 1
        // ex) 2의 왼쪽 자식? 2의 인덱스는 2, 왼쪽 자식의 인덱스는 (2 * 2) + 1 => 5
        // ex) 3의 오른쪽 자식? 3의 인덱스는 3, 오른쪽 자식의 인덱스는 (3 * 2) + 2 => 8

        // -> 인덱스로 접근이 가능하니 노드 기반보다 배열 기반이 훨씬 더 효율적이다


        static void Main(string[] args)
        {
            // 기준을 가지고 빨리빨리 처리해야 함(응급실 상황?)
            Queue<string> queue = new Queue<string>();

            queue.Enqueue("환자1 - 감기(30년 뒤에 죽어)");
            queue.Enqueue("환자2 - 타박상(60년 뒤에 죽어)");
            queue.Enqueue("환자3 - 심장마비(1분 뒤에 죽어)");

            // 큐의 구조상 먼저 들어가면 제일 먼저 나옴(선입 선출)
            // 우선순위에 따라 먼저 처리하고 싶은 데이터가 있을 수 있음 -> 대기열 보다 기준이 필요함
            while(queue.Count > 0)
            {
                Console.WriteLine(queue.Dequeue());
            }

            // PriorityQueue : 우선순위 큐 
            PriorityQueue<string, int> pq = new PriorityQueue<string, int>();
            // 우선순위 큐는 데이터와 함께 우선순위도 같이 넣어줌
            // 우선순위가 중복은 되나 이 경우에는 선입선출을 보장해 주지 않음(랜덤)
            pq.Enqueue("환자1 - 감기(30년뒤)", 5);        // 5 순위
            pq.Enqueue("환자2 - 타박상(60년뒤)", 8);      // 8 순위
            pq.Enqueue("환자3 - 심장마비(1분뒤)", 1);     // 1 순위
            pq.Enqueue("환자4 - 교통사고", 3);           // 3 순위
            pq.Enqueue("환자5 - 탈모", 9);               // 9 순위

            // 우선순위 큐는 큐와 기본 사용 방법은 거의 동일하나 우선순위가 들어감으로써 데이터가 변경됨
            while (pq.Count > 3)
            {
                Console.WriteLine(pq.Dequeue()); // 환자3, 환자4
            }

            pq.Enqueue("환자6 - 심장마비(1분뒤)", 1);     // 1 순위
            pq.Enqueue("환자7 - 교통사고", 3);           // 3 순위

            while(pq.Count > 0)
            {
                Console.WriteLine(pq.Dequeue()); // 환자6, 환자7, 환자1, 환자2, 환자5
            }

            // 내림차순 : int 우선순위에 * -1을 적용하여 사용
            PriorityQueue<string, int> pq2 = new PriorityQueue<string, int>();

            pq2.Enqueue("Data1", -1);
            pq2.Enqueue("Data2", -7);
            pq2.Enqueue("Data3", -5);
            pq2.Enqueue("Data4", -3);
            pq2.Enqueue("Data5", -9);
        }
    }
}
